# Midscene 模型选择指南 - 视觉模型 vs 非视觉模型

## 📋 目录
1. [Midscene 的设计理念](#1-midscene-的设计理念)
2. [是否必须使用视觉模型？](#2-是否必须使用视觉模型)
3. [非视觉模型的替代方案](#3-非视觉模型的替代方案)
4. [方案对比分析](#4-方案对比分析)
5. [推荐方案](#5-推荐方案)

---

## 1. Midscene 的设计理念

### 核心定位：**视觉驱动的 AI 自动化框架**

Midscene.js 的设计理念是**模拟人类使用界面的方式**：
- 👁️ **看屏幕** - 使用视觉语言模型(VLM)分析页面截图
- 🧠 **理解内容** - AI 理解页面语义，而不是依赖 DOM 结构
- 👆 **自然交互** - 使用自然语言描述操作，而不是 CSS Selector

### 为什么选择视觉模型？

```
传统自动化方式:
用户 → 编写 CSS Selector/XPath → 脚本执行 → 页面 DOM
❌ 问题: DOM 结构变化导致脚本失效

Midscene 视觉方式:
用户 → 自然语言描述 → AI 视觉理解 → 执行操作
✅ 优势: 页面结构变化不影响，更接近人类思维
```

---

## 2. 是否必须使用视觉模型？

### 简短回答：**不一定**

Midscene 提供了多种方案：

| 方案 | 是否需要视觉模型 | 适用场景 |
|------|------------------|----------|
| **纯视觉模式** | ✅ 必须 | 复杂页面、动态内容、不确定 DOM 结构 |
| **混合模式** | ⚠️ 可选 | 部分元素使用 selector，部分使用 AI |
| **Puppeteer/Playwright 原生** | ❌ 不需要 | 简单固定结构、已知 selector |
| **DOM 结构分析** | ⚠️ 可选 | 使用 Accessibility Tree |

---

## 3. 非视觉模型的替代方案

### 方案 1: 直接使用 Puppeteer/Playwright 原生 API

**完全不使用 Midscene，纯传统自动化：**

```typescript
import puppeteer from 'puppeteer';

async function traditionalApproach() {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  // 1. 访问百度
  await page.goto('https://www.baidu.com');

  // 2. 使用 CSS Selector 定位元素
  await page.type('#kw', '数字浙江');  // 搜索框的 ID
  await page.click('#su');              // 搜索按钮的 ID

  // 3. 等待搜索结果
  await page.waitForSelector('.result');

  // 4. 点击百度百科链接（使用 XPath）
  await page.evaluate(() => {
    const link = Array.from(document.querySelectorAll('a')).find(
      a => a.textContent?.includes('百度百科') && a.textContent?.includes('数字浙江')
    );
    link?.click();
  });

  // 5. 提取信用代码（使用 XPath 或 querySelector）
  const creditCode = await page.evaluate(() => {
    const text = document.body.innerText;
    const match = text.match(/统一社会信用代码[：:]\s*([A-Z0-9]{18})/);
    return match ? match[1] : null;
  });

  console.log('信用代码:', creditCode);
  await browser.close();
}
```

**优点:**
- ✅ 不需要 AI 模型，成本为零
- ✅ 速度快，不需要等待 AI 推理
- ✅ 精确控制每个步骤

**缺点:**
- ❌ 需要知道确切的 selector（需要查看页面源码）
- ❌ 页面结构变化会导致脚本失效
- ❌ 维护成本高
- ❌ 对于动态内容和复杂页面很困难

---

### 方案 2: 混合模式 - Midscene + 传统 Selector

**部分使用 AI，部分使用 selector：**

```typescript
import { PuppeteerAgent } from '@midscene/web/puppeteer';
import puppeteer from 'puppeteer';

async function hybridApproach() {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  const agent = new PuppeteerAgent(page);

  await page.goto('https://www.baidu.com');

  // 🎯 方式 1: 使用传统 selector（已知 ID）
  await page.type('#kw', '数字浙江');
  await page.click('#su');

  // ⏳ 等待搜索结果
  await page.waitForSelector('.result', { timeout: 10000 });

  // 🤖 方式 2: 使用 AI 查找百科链接（避免写复杂 selector）
  await agent.aiTap('数字浙江百度百科链接');

  // ⏳ 等待百科页面加载
  await page.waitForNavigation({ waitUntil: 'networkidle2' });

  // 🎯 方式 3: 先尝试传统方式
  let creditCode = await page.evaluate(() => {
    const text = document.body.innerText;
    const match = text.match(/统一社会信用代码[：:]\s*([A-Z0-9]{18})/);
    return match ? match[1] : null;
  });

  // 🤖 方式 4: 如果传统方式找不到，使用 AI
  if (!creditCode) {
    creditCode = await agent.aiQuery<string>(
      '提取统一社会信用代码的值（18位）'
    );
  }

  console.log('信用代码:', creditCode);
  await browser.close();
}
```

**优点:**
- ✅ 降低 AI 调用成本（只在必要时使用）
- ✅ 速度快（简单元素用 selector）
- ✅ 可靠性高（复杂元素用 AI）

**缺点:**
- ⚠️ 仍需要部分 selector 知识
- ⚠️ 代码复杂度中等

---

### 方案 3: 使用 Accessibility Tree（无视觉）

**基于语义树而非视觉：**

```typescript
import { PuppeteerAgent } from '@midscene/web/puppeteer';
import puppeteer from 'puppeteer';

async function accessibilityApproach() {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();

  await page.goto('https://www.baidu.com');

  // 获取 Accessibility Tree
  const snapshot = await page.accessibility.snapshot();

  // 使用 Accessibility 属性查找元素
  const searchBox = await page.evaluate(() => {
    return Array.from(document.querySelectorAll('*')).find(
      el => el.getAttribute('aria-label') === '搜索框' ||
            el.getAttribute('name') === 'wd'
    );
  });

  // ... 后续操作
}
```

**优点:**
- ✅ 不需要视觉模型
- ✅ 更关注语义而非视觉

**缺点:**
- ❌ 很多网站 Accessibility 标注不完整
- ❌ 复杂页面仍然困难

---

### 方案 4: 使用非视觉 LLM（文本模型）

**使用 GPT-4 等文本模型分析 DOM：**

```typescript
import { PuppeteerAgent } from '@midscene/web/puppeteer';
import puppeteer from 'puppeteer';
import OpenAI from 'openai';

async function textLLMApproach() {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  const openai = new OpenAI();

  await page.goto('https://www.baidu.com');

  // 1. 提取页面的 HTML 或纯文本
  const htmlContent = await page.content();
  const textContent = await page.evaluate(() => document.body.innerText);

  // 2. 使用文本 LLM 分析
  const response = await openai.chat.completions.create({
    model: 'gpt-4',
    messages: [
      {
        role: 'system',
        content: '你是一个网页分析助手，帮助提取网页信息。'
      },
      {
        role: 'user',
        content: `从以下网页文本中提取统一社会信用代码：\n\n${textContent}`
      }
    ]
  });

  const creditCode = response.choices[0].message.content;
  console.log('信用代码:', creditCode);

  await browser.close();
}
```

**优点:**
- ✅ 不需要视觉模型（成本更低）
- ✅ 对文本内容理解能力强

**缺点:**
- ❌ 无法理解视觉布局
- ❌ 无法准确定位元素位置
- ❌ 对于复杂页面效果差

---

## 4. 方案对比分析

### 对于"数字浙江信用代码查询"任务

| 方案 | 实现难度 | 成本 | 稳定性 | 维护成本 | 推荐度 |
|------|---------|------|--------|----------|--------|
| **纯 Midscene 视觉** | ⭐⭐⭐⭐⭐ 简单 | 💰💰 中 | ⭐⭐⭐⭐⭐ 高 | ⭐⭐⭐⭐⭐ 低 | ⭐⭐⭐⭐⭐ 强烈推荐 |
| **混合模式** | ⭐⭐⭐⭐ 中等 | 💰 低 | ⭐⭐⭐⭐ 高 | ⭐⭐⭐ 中 | ⭐⭐⭐⭐ 推荐 |
| **纯 Puppeteer** | ⭐⭐ 困难 | 免费 | ⭐⭐ 低 | ⭐⭐ 高 | ⭐⭐ 不推荐 |
| **Accessibility Tree** | ⭐ 很困难 | 免费 | ⭐ 很低 | ⭐⭐ 高 | ⭐ 不推荐 |
| **文本 LLM** | ⭐⭐⭐ 中等 | 💰 低 | ⭐⭐⭐ 中 | ⭐⭐⭐ 中 | ⭐⭐⭐ 可选 |

### 详细分析

#### 任务关键步骤：
1. ✅ 百度搜索 - **视觉/Selector 都可以**
2. ⚠️ 找到百度百科链接 - **视觉更优**（不确定链接位置）
3. ⚠️ 滚动查找信用代码 - **视觉更优**（不确定位置）
4. ✅ 提取18位代码 - **文本匹配即可**

**结论:**
- 步骤 1, 4 可以不用视觉模型
- 步骤 2, 3 使用视觉模型效果最佳

---

## 5. 推荐方案

### 🥇 方案 A: 纯 Midscene 视觉（强烈推荐）

**适用场景:**
- 页面结构复杂或经常变化
- 需要长期维护的测试
- 开发时间紧张
- 对成本不太敏感

**优点:**
- 🎯 开发速度最快
- 🛡️ 最稳定，抗页面变化
- 📝 代码最简洁
- 🧠 最接近人类思维

**示例代码:**
```typescript
await agent.aiAction('在百度搜索数字浙江并点击百度百科');
await agent.aiAction('滚动查找统一社会信用代码');
const code = await agent.aiQuery('提取统一社会信用代码');
```

---

### 🥈 方案 B: 混合模式（推荐）

**适用场景:**
- 对成本敏感
- 页面部分结构固定
- 需要精细控制
- 有一定开发经验

**优点:**
- 💰 成本更低
- ⚡ 速度更快
- 🎯 关键步骤使用 AI

**示例代码:**
```typescript
// 固定步骤用 selector
await page.type('#kw', '数字浙江');
await page.click('#su');

// 复杂步骤用 AI
await agent.aiTap('百度百科链接');
const code = await agent.aiQuery('提取信用代码');
```

---

### 🥉 方案 C: 纯 Puppeteer（不推荐）

**适用场景:**
- 预算为零
- 页面结构非常固定
- 一次性脚本
- 非常简单的任务

**缺点:**
- 维护成本极高
- 页面变化即失效
- 需要手动分析 DOM

---

## 6. 关于 Qwen vs Claude 的问题

### Qwen 找不到"百度一下"的原因

**不是模型能力问题，而是配置问题：**

1. **headless: true**
   - 无头模式可能导致页面渲染不完整
   - 某些动态元素可能未加载

2. **视口太小**
   - 之前配置: 1280x768
   - 百度可能显示简化版界面

3. **页面状态错误**
   - 可能已经在搜索结果页（没有"百度一下"按钮）

### 现在修复后的配置

```typescript
headless: false,         // 可视化模式
viewport: 1920x1080,     // 更大视口
timeout: 60000,          // 更长超时
waitUntil: 'networkidle2' // 确保加载完成
```

**现在 Claude 和 Qwen 应该都能正常工作！**

---

## 7. 总结建议

### 对于你的"数字浙江"任务

**推荐使用: 纯 Midscene 视觉模式（方案 A）**

理由：
1. ✅ 页面结构不确定（百科链接位置、信用代码位置）
2. ✅ 需要智能滚动查找
3. ✅ 一次开发，长期使用
4. ✅ Claude Sonnet 4.5 视觉识别能力强

### 成本对比

| 模型 | 单次成本 | 月度成本（100次） |
|------|---------|------------------|
| Claude Sonnet 4.5 | ~$0.05 | $5 |
| Qwen3-VL (硅基流动) | ~$0.01 | $1 |
| 纯 Puppeteer | $0 | $0 |

**如果预算允许，强烈推荐视觉模型！**

---

## 8. 快速切换方案

### 当前使用：Claude 视觉模式

如果想切换到其他方案：

#### 切换回 Qwen:
编辑 `.env`，取消注释 Qwen 配置，注释 Claude 配置

#### 切换到混合模式:
保持 Midscene Agent，但部分步骤用 `page.type()`, `page.click()`

#### 切换到纯 Puppeteer:
完全不使用 Midscene Agent，直接用 Puppeteer API

---

## 9. 下一步建议

1. ✅ **先测试当前方案** - Claude 视觉模式应该能工作
2. ⚠️ **如果成本过高** - 考虑混合模式
3. ❌ **不要使用纯 Puppeteer** - 维护成本太高

需要我帮你实现混合模式的示例吗？
